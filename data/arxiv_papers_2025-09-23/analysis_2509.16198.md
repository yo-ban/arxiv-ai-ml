# RPG: A Repository Planning Graph for Unified and Scalable Codebase Generation

## 基本情報
- arXiv ID: 2509.16198v1 (https://arxiv.org/abs/2509.16198)
- 著者: Jane Luo, Xin Zhang, Steven Liu, Jie Wu, Yiming Huang, Yangyu Huang, Chengyu Yin, Ying Xin, Jianfeng Liu, Yuefeng Zhan, Hao Sun, Qi Chen, Scarlett Li, Mao Yang
- 所属: Microsoft, Tsinghua University, University of California San Diego
- 投稿日: 2025年09月23日
- カテゴリ: cs.SE, cs.AI

## 簡単に説明すると
この論文は、大規模言語モデルを使ってプログラムのソースコード全体（リポジトリ）を自動生成する画期的な手法「ZeroRepo」を提案しています。従来は関数レベルやファイルレベルのコード生成が主流でした。しかし実際のソフトウェア開発では複数のファイル、クラス、モジュール間の複雑な依存関係を持つ完全なプロジェクトを作成する必要があります。

ZeroRepoの核となるのは「Repository Planning Graph（RPG）」という特殊なグラフ構造です。このグラフは、ソフトウェアの機能要件から実装詳細まで、階層的な情報整理を行います。従来の自然言語による曖昧な計画とは異なり、明確な構造を持つため、一貫性のある大規模コード生成が可能になります。

実験では、RepoCraftという新しいベンチマークで評価されました。平均36,000行のコードを生成し、既存の最強手法（Claude Code）の約3.9倍、他手法の約64倍の規模を達成しています。機能カバレッジ81.5%、成功率69.7%を記録し、既存手法を上回る性能を示しています。

## 1. 研究概要
### 1.1 背景と動機

大規模言語モデルは関数レベルやファイルレベルのコード生成では優秀な性能を示しています。しかし完全なソフトウェアリポジトリをゼロから生成することは根本的な挑戦となっています。この課題の核心は、高レベルなユーザー意図と、ファイル、クラス、依存関係の複雑なネットワークを持つリポジトリの実装との間にある巨大なギャップです。

このギャップを埋めるため、段階的な計画プロセスが必要です。このプロセスは2つの相補的な段階に自然に分解されます。まず「提案レベル計画」では、何を構築するかを決定し、機能範囲と主要な能力を定義します。次に「実装レベル計画」では、どのように構築するかを決定し、ファイル構造、インターフェース、依存関係、データフローを指定します。

既存のアプローチは3つのパラダイムに分類されます。分散計画では、専門的な役割（マネージャー、アーキテクト、エンジニア）を持つマルチエージェント協調を活用します。段階的計画では、まずアーキテクチャスケルトンを確立し、その後詳細なコードに展開する固定ワークフローに従います。外部化反復計画では、中間計画を外部化し（markdownファイルなど）、反復を通じて改良する汎用エージェントフレームワークを採用します。

しかし、これらのアプローチは共通の脆弱性を抱えています。計画の中間表現として自然言語を利用していることです。自然言語は本質的に曖昧で、構造化されておらず、長期間にわたって脆弱です。これによって、不安定な提案レベル計画と断片化された実装レベル計画という2つの失敗モードが生じます。

### 1.2 主要な貢献

この研究の主要な貢献は、リポジトリ生成のための統合的で構造化されたアプローチの開発です。従来の自然言語ベースの計画とは根本的に異なる手法を提案しています。

- Repository Planning Graph（RPG）の導入。機能目標、ファイル構造、データフロー、関数設計を統合する統一表現の開発。
- ZeroRepoフレームワークの開発。RPGに基づく提案レベルおよび実装レベル計画、その後のグラフガイド付きコード生成とテスト検証を含む包括的なフレームワーク。
- RepoCraftベンチマークの構築。ゼロからのリポジトリ生成における計画能力を評価するための6つの実世界プロジェクトと1,052タスクを含むベンチマーク。
- 大規模コード生成の実証。平均36,000行のコードを生成し、最強ベースライン（Claude Code）の約3.9倍、他の手法の約64倍の規模を達成。
- RPGの有効性実証。複雑な依存関係のキャプチャ、準線形スケーリングのサポート、エージェントのリポジトリ理解向上による位置特定の加速化。
- 大規模機能オントロジーの活用。EpiCoder Feature Treeの150万ソフトウェア機能を用いた体系的な機能計画。
- グラフ駆動テスト生成。トポロジカル順序に基づく安定したリポジトリ生成とテスト駆動開発の統合。

## 2. 提案手法
### 2.1 手法の概要

ZeroRepoは、Repository Planning Graph（RPG）を中核とした3段階のフレームワークです。第1段階の「提案レベル構築」では、ユーザー仕様を大規模なFeature Treeから関連機能を取得して機能グラフに変換します。第2段階の「実装レベル構築」では、機能グラフをファイル構造、インターフェース、データフローでエンコードし、完全なRPGを構築します。第3段階の「グラフガイド付きコード生成」では、RPGをトポロジカル順序で走査し、テスト駆動開発を用いて段階的にコンポーネントを実装・検証します。

RPGは、従来の自然言語計画の限界を克服する構造化表現です。ノードは階層的な機能と対応するファイル、クラス、関数を表現し、エッジは意味的関係とデータフローを符号化します。この設計により、長期間にわたる一貫した計画と実装が可能になります。

### 2.2 技術的詳細

RPGの構築プロセスは2つの主要段階で構成されます。提案レベル構築では、EpiCoder Feature Treeから関連機能を探索・活用戦略で選択し、LLMがソフトウェア工学原則に従って機能を凝集性の高いモジュールに再編成します。実装レベル構築では、ファイル構造エンコーディング、データフロー・関数エンコーディングの2つのサブステップでRPGを完成させます。

ファイル構造エンコーディングでは、フォルダレベルでルートノードに専用ディレクトリ名前空間を割り当て、ファイルレベルで中間ノードに実行可能ファイルを割り当てます。データフロー・関数エンコーディングでは、モジュール間・モジュール内のデータフローエッジを追加し、共通パターンをベースクラスとして抽象化し、リーフ機能を実行可能インターフェースにクラスタリングします。

コード生成段階では、RPGのトポロジカル順序に従って実装を進行し、各ノードでテスト駆動開発を適用します。グラフガイド付きローカライゼーションとエディティングにより、依存関係を考慮した安定した実装を実現します。

### 2.3 新規性

本研究の新規性は、構造化グラフ表現による計画と実装の統一にあります。従来手法が自然言語に依存していたのに対し、RPGは明示的な階層構造と意味的関係を持つ永続的表現を提供します。これにより、計画の一貫性と実装の品質が向上します。

大規模機能オントロジーの活用も重要な革新です。150万機能を含むFeature Treeを用いることで、体系的で偏りのない機能選択が可能になります。探索・活用戦略により、精度と多様性のバランスを取った機能計画を実現します。

グラフ駆動の実装順序決定により、依存関係を考慮した安定したコード生成が可能です。トポロジカル順序による実装は、従来の任意順序や固定順序と比較して、エラーの伝播を防ぎ、デバッグを容易にします。

テスト駆動開発との統合により、生成されたコードの品質と信頼性を保証します。各コンポーネントの実装時にテストを生成・実行することで、継続的な検証を行います。

## 3. 実験結果
### 3.1 実験設定

実験では、RepoCraftという新しいベンチマークを用いて評価を行いました。RepoCraftは6つの実世界プロジェクトから構成され、合計1,052のタスクを含みます。対象プロジェクトには、機械学習ライブラリ、ウェブフレームワーク、データ処理ツール、ユーティリティライブラリなど、多様なドメインが含まれています。

評価指標として、機能カバレッジ（実装された機能の割合）、パス率（テストが成功したタスクの割合）、コード規模（生成された行数）を使用しました。比較対象は、Claude Code、OpenHands、Gemini CLI、Paper2Codeなどの最新手法です。

実験環境では、NVIDIA A100 GPUを使用し、各手法に同一の計算リソースと時間制限を設定しました。公平な比較のため、すべての手法で同じプロンプト形式とタスク仕様を使用しています。

### 3.2 主要な結果

ZeroRepoは、すべての評価指標で既存手法を上回る性能を示しました。機能カバレッジは81.5%を達成し、最強ベースラインのClaude Code（54.2%）を27.3ポイント上回りました。パス率は69.7%を記録し、Claude Code（33.9%）を35.8ポイント上回る結果となりました。

コード規模では平均36,000行を生成し、Claude Code（9,200行）の約3.9倍、他の手法（平均560行）の約64倍の規模を達成しました。この結果は、RPGによる体系的な計画が大規模なコード生成を可能にすることを示しています。

定性的な分析では、生成されたリポジトリが適切なモジュール構造、一貫したインターフェース設計、包括的なテストカバレッジを持つことが確認されました。特に、複雑な依存関係を持つプロジェクトでも、論理的で保守しやすいコード構造を維持していました。

### 3.3 既存手法との比較

既存手法との詳細比較により、ZeroRepoの優位性が明確になりました。マルチエージェント手法（ChatDev、MetaGPT）は小規模なプロトタイプ生成に適していますが、複雑な依存関係を持つ大規模プロジェクトでは限界を示しました。平均生成行数は300-800行程度で、実用的な規模に達していませんでした。

段階的計画手法（Paper2Code、AutoP2C）は構造化されたアプローチを取りますが、固定ワークフローの制約により柔軟性に欠けていました。特に、要件変更や設計調整への対応が困難で、最終的な成功率は20%以下にとどまりました。

汎用エージェント手法（Claude Code、OpenHands）は高い品質のコードを生成しますが、長期間の一貫性を維持することが困難でした。自然言語による計画の曖昧性により、実装途中で方向性が変わることが頻繁に観察されました。

ZeroRepoは、これらの限界を構造化されたRPG表現により克服し、一貫した大規模生成を実現しています。

## 4. 実用性評価
### 4.1 実装の容易性

ZeroRepoの実装は、明確に定義されたアーキテクチャにより比較的容易です。主要コンポーネントはFeature Tree構築、RPG生成、コード生成の3つのモジュールに分離されており、各モジュールは独立して開発・テスト可能です。

技術的要件は標準的で、PyTorchやTransformersなどの一般的なライブラリを使用します。特殊なハードウェアや独自のインフラストラクチャは不要で、既存の開発環境に容易に統合できます。

APIインターフェースは直感的で、ユーザーは高レベルな仕様を提供するだけで、詳細な実装計画はシステムが自動生成します。これにより、ソフトウェア工学の専門知識を持たないユーザーでも利用可能です。

### 4.2 計算効率

計算効率の観点では、RPGの構築とコード生成の両方で最適化が施されています。Feature Treeからの機能選択は、ベクトル埋め込みによる効率的な検索により実現され、150万機能の中から関連機能を数秒で特定できます。

RPGの構築は段階的に行われ、不要な計算を避けながら必要な情報のみを追加していきます。グラフのトポロジカル順序による実装は、依存関係に基づく自然な順序を提供し、バックトラッキングや再実装の必要性を最小限に抑えます。

コード生成では、並列処理を活用して独立なコンポーネントを同時に実装できます。平均36,000行のコードを生成する場合でも、実行時間は数時間程度に収まり、実用的なレベルを達成しています。

### 4.3 応用可能性

応用可能性は非常に高く、様々なドメインでの活用が期待されます。機械学習ライブラリ、ウェブアプリケーション、データ処理パイプライン、システムユーティリティなど、幅広い種類のソフトウェアプロジェクトに対応できます。

教育分野では、プログラミング学習者が完全なプロジェクト構造を理解するためのツールとして活用できます。生成されたコードは適切にコメント化され、モジュール構造が明確で、学習材料として価値があります。

産業応用では、プロトタイプ開発の加速、レガシーシステムの現代化、新技術の実証実験などに利用できます。特に、アイデアから動作するプロトタイプまでの時間を大幅に短縮できる点が魅力的です。

研究分野では、新しいアルゴリズムやアーキテクチャの実装支援ツールとして機能し、研究者が本質的な問題に集中できる環境を提供します。

## 5. まとめと所感
### 5.1 論文の意義

本論文は、コード生成分野における重要なパラダイムシフトを示しています。従来の自然言語ベースの計画から、構造化されたグラフ表現への移行は、長期間にわたる一貫したソフトウェア開発を可能にする画期的なアプローチです。

技術的貢献として、RPGは機能設計から実装詳細までを統一的に表現する初の体系的手法です。これにより、従来は困難だった大規模リポジトリの自動生成が現実的になりました。150万機能を含むFeature Treeの活用は、体系的な機能計画の重要性を実証しています。

実用的意義では、生成されたコードの規模と品質が既存手法を大きく上回っており、実際の開発現場での活用可能性を示しています。特に、プロトタイプ開発やレガシーシステムの現代化において、開発効率の向上が期待されます。

研究分野への影響として、構造化表現による計画手法は他のタスクにも応用可能で、AI支援ソフトウェア開発の新しい方向性を示しています。

### 5.2 今後の展望

短期的な発展として、より大規模で複雑なプロジェクトへの対応が挙げられます。現在の平均36,000行から、10万行を超える企業レベルのプロジェクトへの拡張が次の目標です。また、より多様なプログラミング言語への対応により、実用性をさらに向上させることができます。

技術的改善では、RPGの自動最適化機能の追加が重要です。生成過程で発見された設計問題を自動的に検出し、グラフ構造を調整する機能により、より高品質なコードを生成できます。また、インクリメンタルな開発をサポートすることで、既存プロジェクトへの機能追加も可能になります。

応用分野の拡大では、ドメイン特化型の拡張が有望です。ウェブ開発、モバイルアプリケーション、組み込みシステムなど、特定分野に最適化されたFeature Treeとテンプレートの開発により、さらに実用的なツールとなります。

長期的には、AIペアプログラミングの一部として統合され、人間の開発者との協調作業を支援するツールに発展することが期待されます。また、自動テスト生成や継続的インテグレーションとの統合により、完全な開発パイプラインの自動化も視野に入ります。
